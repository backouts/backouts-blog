---
title: 'TLS ì‹œë¦¬ì¦ˆ 02: RSAë¡œ í‚¤ êµí™˜í•´ë³´ê¸°'
date: '2025-12-18'
tags: ['TLS Series']
draft: false
summary: 'RSAë¥¼ êµ¬í˜„í•´ì„œ ê°„ë‹¨í•œ í‚¤ êµí™˜ì„ í•´ë³´ê¸°'
images: ['']
authors: ['default']
#layout: PostLayout
---

ì•ì˜ ê¸€ì—ì„œ RSAë¥¼ ì´í•´í•˜ê¸° ìœ„í•´  
ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜, í™•ì¥ ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜,  
ê·¸ë¦¬ê³  ëª¨ë“ˆëŸ¬ ì—­ì›ê¹Œì§€ í•˜ë‚˜ì”© ì •ë¦¬í•´ë´¤ìŠµë‹ˆë‹¤.

ì´ì œëŠ” ê·¸ ì´ë¡ ë“¤ì„ ì‹¤ì œ ì½”ë“œì—ì„œ ì‚¬ìš©í•´ ë³¼ ì°¨ë¡€ì…ë‹ˆë‹¤.

ì´ë²ˆ ê¸€ì—ì„œëŠ”  
ì œê°€ ë§Œë“¤ê³  ìˆë˜ TCP ê¸°ë°˜ ì±„íŒ… client, server ì½”ë“œì— RSAë¥¼ ì§ì ‘ ë¶™ì—¬ë³´ê² ìŠµë‹ˆë‹¤.

## ì´ë²ˆ ë‹¨ê³„ì—ì„œ ëª©í‘œ

ì´ë²ˆ ê¸€ì˜ ëª©í‘œëŠ” ê°„ë‹¨í•©ë‹ˆë‹¤.

- ì„œë²„ê°€ _RSA_ ê³µê°œí‚¤, ê°œì¸í‚¤ë¥¼ ë§Œë“ ë‹¤.
- í´ë¼ì´ì–¸íŠ¸ëŠ” ì„œë²„ì˜ ê³µê°œí‚¤ë¥¼ ë°›ëŠ”ë‹¤.
- í´ë¼ì´ì–¸íŠ¸ëŠ” ëœë¤í•œ ìˆ«ì í•˜ë‚˜ë¥¼ *RSA*ë¡œ ì•”í˜¸í™”í•´ ì„œë²„ì—ê²Œ ë³´ë‚¸ë‹¤.
- ì„œë²„ëŠ” ê·¸ ê°’ì„ ìê¸° ê°œì¸í‚¤ë¡œ ë³µí˜¸í™”í•œë‹¤.

ì´ ëœë¤í•œ ìˆ«ìëŠ” ì´í›„ì—  
`ëŒ€ì¹­í‚¤(AES)`ë¡œ ì•”í˜¸í™”í•˜ê¸° ìœ„í•œ ì„¸ì…˜ í‚¤ ì—­í• ì„ í•˜ê²Œ ë©ë‹ˆë‹¤.

ì•„ì§ AESê¹Œì§€ëŠ” ê°€ì§€ ì•Šê³   
RSAê°€ ì‹¤ì œë¡œ `í‚¤ë¥¼ ì•ˆì „í•˜ê²Œ ì „ë‹¬í•˜ëŠ” ê³¼ì •`ì— ì–´ë–»ê²Œ ì“°ì´ëŠ”ì§€ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

---

# ğŸ”¥ RSA êµ¬í˜„í•´ë³´ê¸°

RSAì˜ ê¸°ëŠ¥ì„ í•˜ê¸° ìœ„í•œ ëª¨ë“ˆì¸ `rsa.py`ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.  
êµ¬ì¡°ë¥¼ ê°„ë‹¨íˆ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- ì†Œìˆ˜ ìƒì„±
  - Millerâ€“Rabin í…ŒìŠ¤íŠ¸ ì´ìš©
- í‚¤ ìƒì„±
  - ì„œë¡œ ë‹¤ë¥¸ í° ì†Œìˆ˜ p, q
  - `p, q => n`, `Ï†(n) => e, d`
- ì•”í˜¸í™”
  - `m^e mod n`
- ë³µí˜¸í™”
  - `c^d mod n`

ì¦‰, ì´ íŒŒì¼ì€
**RSAê°€ ëŒì•„ê°€ê¸° ìœ„í•œ ìˆ˜í•™ ì—”ì§„** ì—­í• ì…ë‹ˆë‹¤.

ê°„ë‹¨í•˜ê²Œ  
`pubkey, privkey = generate_keypair()`  
ì´ í•œ ì¤„ì˜ ì½”ë“œë¡œ _ê³µê°œí‚¤(n, e)_, _ê°œì¸í‚¤(n, d)_ ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<details className="border p-2 rounded-md bg-gray-50 mb-4">
  <summary className="cursor-pointer font-bold">ğŸ“Œ rsa.py ì½”ë“œ í¼ì¹˜ê¸°</summary>
    ```python
    import random

    def extended_euclidean(a, b):
        # í™•ì¥ ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜
        # a*x + b*y = gcd(a, b)ë¥¼ ë§Œì¡±í•˜ëŠ” x, yë¥¼ êµ¬í•œë‹¤.
        # RSAì—ì„œëŠ” ì´ x ê°’ì´ ëª¨ë“ˆëŸ¬ ì—­ì›ì´ ëœë‹¤.

        if b == 0:
            # ë” ì´ìƒ ë‚˜ëˆŒ ìˆ˜ ì—†ìœ¼ë©´ aê°€ gcd
            return 1, 0, a

        # ë‹¤ìŒ ë‹¨ê³„ë¡œ ë‚´ë ¤ê°€ì„œ ê³„ìˆ˜ë“¤ì„ ë¨¼ì € êµ¬í•œë‹¤
        x1, y1, g = extended_euclidean(b, a % b)

        # a = b*q + r  (r = a % b)
        # r = a - b*q ë¥¼ ì´ìš©í•´ ê³„ìˆ˜ë¥¼ ë‹¤ì‹œ ì •ë¦¬
        x = y1
        y = x1 - (a // b) * y1

        return x, y, g

    def modinv(a, n):
        # aì˜ ëª¨ë“ˆëŸ¬ ì—­ì› (a^-1 mod n)ì„ êµ¬í•¨
        # a * x â‰¡ 1 (mod n)

        x, _, g = extended_euclidean(a, n)

        # ì„œë¡œì†Œê°€ ì•„ë‹ˆë©´ ì—­ì›ì´ ì—†ìŒ
        if g != 1:
            raise ValueError("ì—­ì›ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

        # ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ mod n ë²”ìœ„ë¡œ ì •ë¦¬
        return x % n

    # Millerâ€“Rabin í™•ë¥ ì  ì†Œìˆ˜ íŒë³„
    def is_probable_prime(n, k=10):
        if n < 2:
            return False

        # ì‘ì€ ì†Œìˆ˜ ì˜ˆì™¸ ì²˜ë¦¬
        small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        if n in small_primes:
            return True
        if any(n % p == 0 for p in small_primes):
            return False

        # n - 1 = 2^r * d (dëŠ” í™€ìˆ˜)
        r = 0
        d = n - 1
        while d % 2 == 0:
            r += 1
            d //= 2

        # kë²ˆì˜ ëœë¤ í…ŒìŠ¤íŠ¸
        for _ in range(k):
            a = random.randrange(2, n - 2)
            x = pow(a, d, n)

            if x == 1 or x == n - 1:
                continue

            for _ in range(r - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False

        return True

    def generate_prime(bits):
        # ì§€ì •í•œ ë¹„íŠ¸ ê¸¸ì´ì˜ ì†Œìˆ˜ í•˜ë‚˜ë¥¼ ìƒì„±í•œë‹¤

        while True:
            # ë¹„íŠ¸ ê¸¸ì´ë¥¼ ë§ì¶˜ ëœë¤ í›„ë³´
            cand = random.getrandbits(bits)
            # MSB = 1
            # bits ë§Œí¼ì˜ ìë¦¿ìˆ˜ ë³´ì¥
            cand |= (1 << (bits - 1))
            # í™€ìˆ˜ë¡œ ì œí•œ
            cand |= 1

            # Millerâ€“Rabin í†µê³¼ ì‹œ ì±„íƒ
            if is_probable_prime(cand):
                return cand

    def generate_keypair(bits=1024, e=65537):
        # RSA ê³µê°œí‚¤ / ê°œì¸í‚¤ ìƒì„±

        half = bits // 2

        while True:
            # ë‘ ê°œì˜ í° ì†Œìˆ˜ ìƒì„±
            p = generate_prime(half)
            q = generate_prime(half)
            if p == q:
                continue

            n = p * q
            phi = (p - 1) * (q - 1)

            # eì™€ phiëŠ” ì„œë¡œì†Œì—¬ì•¼ í•¨
            _, _, g = extended_euclidean(e, phi)
            if g != 1:
                continue

            d = modinv(e, phi)

            return (n, e), (n, d)

    def rsa_encrypt_int(m, pubkey):
        # RSA ì •ìˆ˜ ì•”í˜¸í™”
        # c = m^e mod n
        n, e = pubkey

        if not (0 <= m < n):
            raise ValueError("m must satisfy 0 <= m < n")

        return pow(m, e, n)


    def rsa_decrypt_int(c, privkey):
        # RSA ì •ìˆ˜ ë³µí˜¸í™”
        # m = c^d mod n
        n, d = privkey

        if not (0 <= c < n):
            raise ValueError("c must satisfy 0 <= c < n")

        return pow(c, d, n)
    ```

</details>

ì´ í”„ë¡œì íŠ¸ì—ì„œëŠ” **ì„œë¡œ ë‹¤ë¥¸ ë‘ ì†Œìˆ˜ p, q**ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´  
*Millerâ€“Rabin íŒë³„ë²•*ì„  
ì†Œìˆ˜ì¸ì§€ ì•„ë‹Œì§€ë¥¼ íŒë³„í•˜ëŠ” ìš©ë„ë¡œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.

ê°„ë‹¨íˆ ìš”ì•½í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- nì´ ì†Œìˆ˜ì¸ì§€ íŒë³„í•˜ëŠ” ê³¼ì •:
  1. n âˆ’ 1ì„ 2ì˜ ê±°ë“­ì œê³± í˜•íƒœë¡œ ë¶„í•´í•©ë‹ˆë‹¤. `(n âˆ’ 1 = 2^r Â· d)`
  2. ëœë¤í•œ ê°’ aë¥¼ ì„ íƒí•´ `a^d mod n`ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
  3. ì´í›„ ì œê³±ì„ `r-1`ë²ˆ ë°˜ë³µí•˜ë©° `mod n` ê°’ì´ `nâˆ’1`ì´ ë‚˜ì˜¤ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
  4. ì´ ê³¼ì •ì„ kë²ˆ ë°˜ë³µí•´ ëª¨ë‘ í†µê³¼í•˜ë©´ ì†Œìˆ˜ì¼ ê°€ëŠ¥ì„±ì´ ë†’ë‹¤ê³  íŒë‹¨í•©ë‹ˆë‹¤.

ì´ì œ ì´ê±¸ ë„¤íŠ¸ì›Œí¬ ì½”ë“œì— ì—°ê²°í•´ë³´ê² ìŠµë‹ˆë‹¤.

---

# â“ ë¨¼ì € í•´ê²°í•´ì•¼ í•  ë¬¸ì œ

RSA êµ¬í˜„ë³´ë‹¤ ë¨¼ì € í•´ê²°í•´ì•¼ í•  ë¬¸ì œê°€ í•˜ë‚˜ ìˆìŠµë‹ˆë‹¤.  
**ì†Œì¼“ì€ intë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ë‹¤.**

RSA í•¨ìˆ˜ëŠ” ëª¨ë‘ ì •ìˆ˜(int) ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.  
í•˜ì§€ë§Œ `ì†Œì¼“ í†µì‹ ì€ bytesë§Œ` ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê·¸ë˜ì„œ ë³€í™˜ê³¼ì •ì´ í•„ìš”í•´ì§‘ë‹ˆë‹¤.  
`intë¥¼ bytes`ë¡œ, `bytesë¥¼ int`ë¡œ ë³€í™˜í•˜ëŠ” ì½”ë“œë¥¼  
í”„ë ˆì´ë°ë•Œ ì‚¬ìš©í•œ `utils.py`ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

ë˜í•œ,  
í”„ë ˆì´ë°ì„ ì¡°ê¸ˆ í™•ì¥í•´ì„œ  
ë©”ì‹œì§€ì— íƒœê·¸ë¥¼ ê°™ì´ ë³´ë‚´ê¸° ìœ„í•œ `tagged`í•¨ìˆ˜ì—­ì‹œ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

<details className="border p-2 rounded-md bg-gray-50 mb-4">
  <summary className="cursor-pointer font-bold">ğŸ“Œ utils.py ì½”ë“œ í¼ì¹˜ê¸°</summary>
    ```python
    import struct

    # ë°”ì´íŠ¸ ë¸”ë¡ì„ ì†¡ì‹ í•˜ëŠ” í•¨ìˆ˜
    def send_block(sock, data):
        length = len(data)
        # ë°ì´í„°ì˜ ê¸¸ì´ë¥¼ 4ë°”ì´íŠ¸ë¡œ íŒ¨í‚¹í•˜ì—¬ ì „ì†¡í•¨
        sock.sendall(struct.pack("!I", length) + data)

    # ë°”ì´íŠ¸ ë¸”ë¡ì„ ìˆ˜ì‹ í•˜ëŠ” í•¨ìˆ˜
    def recv_block(sock):
        # 4ë°”ì´íŠ¸ë¥¼ ë¨¼ì € ìˆ˜ì‹ í•˜ì—¬ ë°ì´í„° ì „ì²´ì˜ ê¸¸ì´ë¥¼ ì•Œì•„ëƒ„
        # ì‹¤ì „ì—ì„œëŠ” recv_exact ê°™ì€ í•¨ìˆ˜ë¡œ 4ë°”ì´íŠ¸ ìˆ˜ì‹ ì„ ë³´ì¥í•˜ëŠ” ê²ƒì´ ë” ì•ˆì „í•¨
        header = sock.recv(4)
        if not header:
            # í—¤ë”ê°€ ì—†ì„ë•Œ ì—ëŸ¬
            raise ConnectionError("í—¤ë”ê°€ ì—†ìŠµë‹ˆë‹¤.")
        length = struct.unpack("!I", header)[0]

        buf = b''
        # ì§€ì •ëœ ê¸¸ì´ë§Œí¼ì˜ ë°ì´í„°ë¥¼ ìˆ˜ì‹ í•˜ì—¬ ë²„í¼ì— ì €ì¥
        while len(buf) < length:
            chunk = sock.recv(length - len(buf))
            if not chunk:
                raise ConnectionError("ë°ì´í„° ìˆ˜ì‹ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
            buf += chunk
        return buf

    # ================================================
    # ì¶”ê°€ ëœ ë¶€ë¶„
    # ================================================

    # intë¥¼ byteë¡œ
    def int_to_bytes(x):
        length = max(1, (x.bit_length() + 7) // 8)
        return x.to_bytes(length, "big")

    # byteë¥¼ intë¡œ
    def bytes_to_int(b):
        return int.from_bytes(b, "big")

    # ë©”ì‹œì§€ë¥¼ íƒœê·¸ì™€ í•¨ê»˜ ë³´ë‚´ê¸° ("PUB", "PRI" ë“±)
    def send_tagged(sock, tag, payload):
        # Enumì¼ ë•Œ ê°’ êº¼ë‚´ê¸°
        if hasattr(tag, "value"):
            tag = tag.value
        send_block(sock, tag.encode("ascii"))
        send_block(sock, payload)

    def recv_tagged(sock):
        tag = recv_block(sock).decode("ascii")
        payload = recv_block(sock)
        return tag, payload
    ```

</details>

ë˜í•œ,  
íƒœê·¸ì— ëŒ€í•œ ì˜¤íƒ€ë¥¼ ì¤„ì´ê¸° ìœ„í•´ `protocol.py`ì— `Enum`ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

<details className="border p-2 rounded-md bg-gray-50 mb-4">
  <summary className="cursor-pointer font-bold">ğŸ“Œ protocol.py ì½”ë“œ í¼ì¹˜ê¸°</summary>
    ```python
    from enum import Enum

    class MsgType(Enum):
        # RSA í•¸ë“œì…°ì´í¬ ê´€ë ¨
        PUB_N = "PUBN"   # ì„œë²„ ê³µê°œí‚¤ n
        PUB_E = "PUBE"   # ì„œë²„ ê³µê°œí‚¤ e
        KEY_C = "KEYC"   # í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ì„¸ì…˜í‚¤(RSA ì•”í˜¸ë¬¸)

        # ì´í›„ ì±„íŒ… ê¸°ëŠ¥ í™•ì¥ìš©
        CHAT  = "CHAT"   # ì¼ë°˜ ì±„íŒ… ë©”ì‹œì§€
        CLOSE = "CLOSE"  # ì •ìƒ ì¢…ë£Œ
        ERROR = "ERROR"  # ì˜¤ë¥˜ ì•Œë¦¼
    ```

</details>

---

# ğŸ‰ ì±„íŒ…ì•±ì— RSA íƒ‘ì¬í•˜ê¸°

ì™€ ë“œë””ì–´ ì—¬ê¸°ê¹Œì§€ ì™”ìŠµë‹ˆë‹¤.  
ì´ ë¶€ë¶„ì€ ì‚¬ì‹¤ ë§¤ìš° ê°„ë‹¨í•©ë‹ˆë‹¤.  
ìœ„ì—ì„œ ìƒì„±í•œ RSA ë°©ì‹ì„ ì‚¬ìš©í•´ í†µì‹ ë§Œ í•˜ë©´ ë˜ë‹ˆê¹Œìš”

## ğŸ’» ì„œë²„ì—ì„œ ê³µê°œí‚¤ ìƒì„±ê³¼ ë³µí˜¸í™”

ì„œë²„ì˜ ì—­í• ì€ ë‹¨ìˆœí•©ë‹ˆë‹¤.

- RSA í‚¤ ìƒì„±
- ê³µê°œí‚¤ ì „ì†¡
- ì•”í˜¸í™”ëœ ì„¸ì…˜ í‚¤ë¥¼ ë°›ì•„ ë³µí˜¸í™”

```python
pubkey, privkey = generate_keypair()
n, e = pubkey
```

ì„œë²„ëŠ” ì—°ê²°ì´ ë“¤ì–´ì˜¤ë©´  
ì´ë ‡ê²Œ RSA í‚¤ë¥¼ ë¨¼ì € ìƒì„±í•©ë‹ˆë‹¤.

ê·¸ ë‹¤ìŒ ê³µê°œí‚¤ (n, e)ë¥¼ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë³´ëƒ…ë‹ˆë‹¤.

```python
send_tagged(conn, MsgType.PUB_N, int_to_bytes(n))
send_tagged(conn, MsgType.PUB_E, int_to_bytes(e))
```

í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚´ì¤€ ì•”í˜¸ë¬¸ì€  
ê°œì¸í‚¤ë¡œ ë³µí˜¸í™”í•©ë‹ˆë‹¤.

```python
tag, payload = recv_tagged(conn)
if tag != MsgType.KEY_C.value:
    raise ValueError(f"unexpected tag: {tag}")

c = bytes_to_int(payload)
m = rsa_decrypt_int(c, privkey)
session_key = m.to_bytes(32, "big")
```

ì´ ì‹œì ì—ì„œ ì„œë²„ëŠ”  
í´ë¼ì´ì–¸íŠ¸ê°€ ë§Œë“  ì„¸ì…˜ í‚¤ë¥¼ ì •í™•íˆ ë³µì›í•˜ê²Œ ë©ë‹ˆë‹¤.

<details className="border p-2 rounded-md bg-gray-50 mb-4">
  <summary className="cursor-pointer font-bold">ğŸ“Œ server_rsa.py ì½”ë“œ í¼ì¹˜ê¸°</summary>
    ```python
    import socket
    import threading

    from utils import recv_block, send_block, send_tagged, recv_tagged, int_to_bytes, bytes_to_int
    from rsa import generate_keypair, rsa_decrypt_int
    from protocol import MsgType

    HOST = '127.0.0.1'
    PORT = 30003
    stop_event = threading.Event()

    def recv_thread(conn):
        try:
            while not stop_event.is_set():
                data = recv_block(conn)
                if not data:
                    break
                print(f"[Client] {data.decode()}")
                print("> ", end="", flush=True)
        except (ConnectionResetError, OSError) as e:
            print(f'\n[*] ìˆ˜ì‹  ì¤‘ ì˜¤ë¥˜: {e}')
        finally:
            stop_event.set()
            try:
                conn.close()
            except:
                pass

    def send_thread(conn):
        try:
            while not stop_event.is_set():
                try:
                    print("> ", end="", flush=True)
                    msg = input()
                except (KeyboardInterrupt, EOFError):
                    print('\n[*] ì„œë²„ ì¢…ë£Œ ì¤‘...')
                    stop_event.set()
                    break

                if not msg:
                    continue

                try:
                    send_block(conn, msg.encode())
                except (BrokenPipeError, OSError, ConnectionResetError) as e:
                    print(f'\n[*] ë©”ì‹œì§€ ì „ì†¡ ì˜¤ë¥˜: {e}')
                    stop_event.set()
                    break
        finally:
            try:
                conn.close()
            except:
                pass

    def rsa_handshake_server(conn):
        # 1. ì„œë²„ê°€ RSA í‚¤ ìƒì„±
        pubkey, privkey = generate_keypair(bits=1024, e=65537)
        n, e = pubkey

        # 2. ê³µê°œí‚¤ ì „ì†¡: tag="PUB", payload = n_bytes or e_bytes
        # taggedë¥¼ 2ë²ˆ ì‚¬ìš©í•´ì„œ nê³¼ e ì „ì†¡
        send_tagged(conn, MsgType.PUB_N, int_to_bytes(n))
        send_tagged(conn, MsgType.PUB_E, int_to_bytes(e))

        # 3. í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ì„¸ì…˜í‚¤ ì•”í˜¸ë¬¸ ë°›ê¸°
        tag, payload = recv_tagged(conn)
        if tag != MsgType.KEY_C.value:
            raise ValueError(f"unexpected tag: {tag}")

        c = bytes_to_int(payload)
        m = rsa_decrypt_int(c, privkey)

        # 4. ì„¸ì…˜í‚¤ ê¸¸ì´ ê³ ì •(32ë°”ì´íŠ¸)ë¡œ ë³µì› (í´ë¼ì´ì–¸íŠ¸ë„ 32ë°”ì´íŠ¸)
        session_key = m.to_bytes(32, "big")
        return session_key

    def main():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            sock.bind((HOST, PORT))
            sock.listen()
            print(f"[Server] {HOST}:{PORT} ëŒ€ê¸°...")

            conn, addr = sock.accept()
            print(f"[Server] {addr} ì ‘ì† í—ˆìš©")

            # ì—¬ê¸°ì„œ RSA í•¸ë“œì…°ì´í¬ ì‹œì‘
            try:
                session_key = rsa_handshake_server(conn)
                print(f"[*] RSA ì„¸ì…˜í‚¤ êµí™˜ ì™„ë£Œ (ì• 8ë°”ì´íŠ¸): {session_key[:8].hex()}")
            except Exception as e:
                print(f"[*] RSA í•¸ë“œì…°ì´í¬ ì‹¤íŒ¨: {e}")
                stop_event.set()
                conn.close()
                return

            # ì´í›„ ì±„íŒ… ìŠ¤ë ˆë“œ ì‹œì‘
            recv_t = threading.Thread(target=recv_thread, args=(conn,))
            send_t = threading.Thread(target=send_thread, args=(conn,))
            recv_t.start()
            send_t.start()

            try:
                while not stop_event.is_set():
                    recv_t.join(timeout=0.5)
                    send_t.join(timeout=0.5)
                    if not recv_t.is_alive() or not send_t.is_alive():
                        stop_event.set()
            except KeyboardInterrupt:
                print("\n[*] `Ctrl + C ê°ì§€` ì„œë²„ ì¢…ë£Œ ì¤‘...")
                stop_event.set()

        finally:
            try:
                sock.close()
            except:
                pass
            print("\n[Server] ì„œë²„ ì¢…ë£Œ")

    if __name__ == "__main__":
        main()

    ```

</details>

## ğŸ” í´ë¼ì´ì–¸íŠ¸ì—ì„œ ê³µê°œí‚¤ ìˆ˜ì‹ ê³¼ ì•”í˜¸í™”

í´ë¼ì´ì–¸íŠ¸ ìª½ íë¦„ë„ ë‹¨ìˆœí•©ë‹ˆë‹¤.

ë¨¼ì € ì„œë²„ë¡œë¶€í„° ê³µê°œí‚¤ë¥¼ ë°›ìŠµë‹ˆë‹¤.

```python
tag, n_bytes = recv_tagged(sock)
n = bytes_to_int(n_bytes)
tag, e_bytes = recv_tagged(sock)
e = bytes_to_int(e_bytes)
pubkey = (n, e) # ê³µê°œí‚¤
```

ê·¸ ë‹¤ìŒ ëœë¤í•œ ìˆ«ìë¥¼ í•˜ë‚˜ ë§Œë“­ë‹ˆë‹¤.

```python
session_key = os.urandom(32)
m = bytes_to_int(session_key)
```

m ê°’ì€ ë°˜ë“œì‹œ `0 â‰¤ m < n` ë²”ìœ„ ì•ˆì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

> í˜„ì¬ RSA í‚¤ ê¸¸ì´ê°€ 1024ë¹„íŠ¸ì´ê¸° ë•Œë¬¸ì—
> 32ë°”ì´íŠ¸(256ë¹„íŠ¸) ì„¸ì…˜ í‚¤ëŠ” í•­ìƒ në³´ë‹¤ ì‘ìŠµë‹ˆë‹¤.

ì´ì œ ì´ ê°’ì„ *RSA*ë¡œ ì•”í˜¸í™”í•©ë‹ˆë‹¤.

```python
c = rsa_encrypt_int(m, pubkey)
send_tagged(sock, MsgType.KEY_C, int_to_bytes(c))
```

ì´ë ‡ê²Œ í•´ì„œ  
ì„œë²„ë§Œ ë³µí˜¸í™”í•  ìˆ˜ ìˆëŠ”  
ê³µê°œí‚¤ë¡œ ì•”í˜¸í™” í•œ ì„¸ì…˜í‚¤ ê°’ì„ ì „ì†¡í•˜ê²Œ ë©ë‹ˆë‹¤.

<details className="border p-2 rounded-md bg-gray-50 mb-4">
  <summary className="cursor-pointer font-bold">ğŸ“Œ client_rsa.py ì½”ë“œ í¼ì¹˜ê¸°</summary>
    ```python
    import socket
    import threading
    import os

    from utils import recv_block, send_block, send_tagged, recv_tagged, int_to_bytes, bytes_to_int
    from rsa import rsa_encrypt_int
    from protocol import MsgType

    HOST = '127.0.0.1'
    PORT = 30003

    stop_event = threading.Event()

    def recv_thread(sock):
        try:
            while not stop_event.is_set():
                data = recv_block(sock)
                if not data:
                    print("\n[*] ì„œë²„ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.")
                    break
                print(f"[Server] {data.decode()}")
                print("> ", end="", flush=True)
        except (ConnectionResetError, OSError) as e:
            print(f'\n[*] ìˆ˜ì‹  ì¤‘ ì˜¤ë¥˜: {e}')
        finally:
            stop_event.set()
            try:
                sock.close()
            except:
                pass

    def send_thread(sock):
        try:
            while not stop_event.is_set():
                try:
                    print("> ", end="", flush=True)
                    msg = input()
                except (KeyboardInterrupt, EOFError):
                    print("\n[*] ì¢…ë£Œ.")
                    stop_event.set()
                    break

                if not msg:
                    continue

                try:
                    send_block(sock, msg.encode())
                except (BrokenPipeError, OSError, ConnectionResetError) as e:
                    print(f'\n[*] ë©”ì‹œì§€ ì „ì†¡ ì˜¤ë¥˜: {e}')
                    stop_event.set()
                    break
        finally:
            try:
                sock.close()
            except:
                pass

    def rsa_handshake_client(sock):
        # 1. ì„œë²„ ê³µê°œí‚¤ ë°›ê¸°
        tag, n_bytes = recv_tagged(sock)
        if tag != MsgType.PUB_N.value:
            raise ValueError(f"unexpected tag: {tag}")
        n = bytes_to_int(n_bytes)

        tag, e_bytes = recv_tagged(sock)
        if tag != MsgType.PUB_E.value:
            raise ValueError(f"unexpected tag: {tag}")
        e = bytes_to_int(e_bytes)

        pubkey = (n, e)

        # 2. ì„¸ì…˜í‚¤ ìƒì„± (32ë°”ì´íŠ¸ ê³ ì •)
        session_key = os.urandom(32)

        # 3. bytes => int
        m = bytes_to_int(session_key)

        # 4. RSA ì•”í˜¸í™”
        c = rsa_encrypt_int(m, pubkey)

        # 5. ì•”í˜¸ë¬¸ ì „ì†¡ (ì •ìˆ˜=>ë°”ì´íŠ¸)
        send_tagged(sock, MsgType.KEY_C, int_to_bytes(c))

        return session_key

    def main():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            sock.connect((HOST, PORT))
            print(f'[Client] {HOST}:{PORT} ì„œë²„ì— ì ‘ì†í–ˆìŠµë‹ˆë‹¤.')

            # ì—¬ê¸°ì„œ RSA í•¸ë“œì…°ì´í¬ ì‹œì‘
            try:
                session_key = rsa_handshake_client(sock)
                print(f"[*] RSA ì„¸ì…˜í‚¤ êµí™˜ ì™„ë£Œ (ì• 8ë°”ì´íŠ¸): {session_key[:8].hex()}")
            except Exception as e:
                print(f"[*] RSA í•¸ë“œì…°ì´í¬ ì‹¤íŒ¨: {e}")
                stop_event.set()
                sock.close()
                return

            # ì±„íŒ… ìŠ¤ë ˆë“œ ì‹œì‘
            recv_t = threading.Thread(target=recv_thread, args=(sock,))
            send_t = threading.Thread(target=send_thread, args=(sock,))
            recv_t.start()
            send_t.start()

            try:
                while not stop_event.is_set():
                    recv_t.join(0.5)
                    send_t.join(0.5)
                    if not recv_t.is_alive() or not send_t.is_alive():
                        stop_event.set()
            except KeyboardInterrupt:
                print("\n[*] `Ctrl+C ê°ì§€` í´ë¼ì´ì–¸íŠ¸ ì¢…ë£Œ.")
                stop_event.set()

        finally:
            try:
                sock.close()
            except:
                pass
            print("\n[Client] í´ë¼ì´ì–¸íŠ¸ ì¢…ë£Œ.")

    if __name__ == '__main__':
        main()

    ```

</details>

<center>![server_rsa.py ì‹¤í–‰](/static/images/tls-series/02/rsa_server.png)</center>
<center>server_rsa.py ì‹¤í–‰</center>

<center>![client_rsa.py ì‹¤í–‰](/static/images/tls-series/02/client_rsa.png)</center>
<center>client_rsa.py ì‹¤í–‰</center>

## â“ ì™œ RSAë¡œ ë©”ì‹œì§€ë¥¼ ì•ˆ ë³´ë‚´ê³  í‚¤ë§Œ ë³´ë‚¼ê¹Œ?

ì—¬ê¸°ì„œ í•œ ê°€ì§€ ì˜ë¬¸ì´ ë“­ë‹ˆë‹¤.

> ê·¸ëƒ¥ RSAë¡œ ì±„íŒ… ë‚´ìš©ì„ ë‹¤ ì•”í˜¸í™”í•˜ë©´ ì•ˆ ë˜ë‚˜?

ê°€ëŠ¥ì€ í•˜ì§€ë§Œ, ì‹¤ì œë¡œëŠ” ê·¸ë ‡ê²Œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

RSAëŠ” ê³„ì‚°ì´ ëŠë¦¬ê¸° ë•Œë¬¸ì—  
ê¸´ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê¸°ì—” ë¶€ë‹´ì´ í¬ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

ê·¸ë˜ì„œ ì‹¤ì œë¡œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.

- RSA
  - ì²˜ìŒ í•œ ë²ˆ, í‚¤ êµí™˜
- AES
  - ê·¸ ì´í›„ ëª¨ë“  ë°ì´í„° í†µì‹ 

ì´ë²ˆ ê¸€ì€ ê·¸ ì¤‘  
RSAê°€ ë‹´ë‹¹í•˜ëŠ” ì—­í• ë§Œ êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤.

---

# ì •ë¦¬

ì´ë²ˆ ê¸€ì—ì„œëŠ”  
ì§ì ‘ êµ¬í˜„í•œ `rsa.py`ë¥¼ ì‚¬ìš©í•´ì„œ  
í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ê°€  
*RSA*ë¥¼ í†µí•´ ê³µí†µì˜ ë¹„ë°€ í‚¤ í•˜ë‚˜ë¥¼ êµí™˜í•˜ëŠ” ê³¼ì •ì„ êµ¬í˜„í•´ë´¤ìŠµë‹ˆë‹¤.

ì´ì œ ë“œë””ì–´ ë‹¤ìŒ ê¸€ì—ì„œëŠ” ì´ ì„¸ì…˜ í‚¤ë¥¼ ì´ìš©í•´ì„œ  
*AES*ë¡œ ë©”ì‹œì§€ë¥¼ ì•”í˜¸í™”í•˜ê³  í†µì‹ í•˜ëŠ” êµ¬ì¡°ë¡œ  
ìì—°ìŠ¤ëŸ½ê²Œ í™•ì¥í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
